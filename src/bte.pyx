#cython: embedsignature=True
#cython: annotation_typing=True
cimport bte
import cython
from cython.operator cimport dereference, postincrement, preincrement
from libcpp.vector cimport vector
from libcpp.string cimport string
from libcpp.set cimport set as cset
from libcpp.map cimport map
from libc.stdint cimport *
from libcpp cimport bool as cbool
import functools
import time
from typing import Optional, Union
import sys
import math
from os.path import exists

def _timer(func, *args, **kwargs):
    @functools.wraps(func)
    def timer_wrap(*args,**kwargs):
        start = time.perf_counter()
        retval = func(*args,**kwargs)
        end = time.perf_counter()
        rt = end-start
        print(f"Finished {func.__name__!r} in {round(rt,4)} seconds",file=sys.stderr)
        return retval
    return timer_wrap

cdef bte.Mutation instantiate_mutation(str mstr):
    """
    Instantiate a Mutation struct from a string.
    """
    cdef bte.Mutation newmut
    cdef int8_t pn, mn
    cdef char pns, mns
    if ':' in mstr:
        chro, info = mstr.split(":")
    else:
        chro = "NC_045512v2"
        info = mstr
    assert len(mstr) > 0
    loc = int(info[1:-1])
    newmut.chrom = chro.encode("UTF-8")
    pns = ord(info[0])
    pn = bte.get_nuc_id(pns)
    newmut.par_nuc = pn
    mns = ord(info[-1])
    mn = bte.get_nuc_id(mns)
    newmut.mut_nuc = mn
    newmut.position = loc
    return newmut

cdef float entropy(vector[float] frequencies):
    """
    Calculate the entropy of a vector of frequencies. Frequencies must be between 0 and 1.
    """
    cdef float ent = 0.0
    cdef int i = 0
    while i < frequencies.size():
        if frequencies[i] > 0.0:
            if frequencies[i] > 1.0:
                raise ValueError("Frequencies must be between 0 and 1.")
            ent += frequencies[i] * math.log(frequencies[i])
        i = i + 1
    return -ent

class AAChange:
    """
    Class container for amino acid translation information. Generated by MATree.translate().
    """
    def __init__(self, gene, aa, nuc, codons):
        """
        Initialize a new AAChange object. Called by MATree.translate().
        """
        self.gene = gene        
        self.aa = aa
        self.original_aa = aa[0]
        self.aa_index = int(aa[1:-1])
        self.alternative_aa = aa[-1]
        self.nuc = nuc
        self.original_nt = nuc[0]
        self.nt_index = int(nuc[1:-1])
        self.alternative_nt = nuc[-1]
        self.mutation_type = nuc[0] + ">" + nuc[-1]
        self.original_codon = codons.split(">")[0]
        self.alternative_codon = codons.split(">")[1]

    def is_synonymous(self):
        """
        Return True if the mutation is synonymous.
        """
        if self.original_aa == self.alternative_aa:
            return True
        else:
            return False

    def aa_string(self):
        """
        Return a string representation of the mutation in the form "gene:refindexalt" e.g. "S:D614G".
        """
        return self.gene + ":" + self.aa

    def __repr__(self):
        fstr = ""
        fstr += "gene: " + self.gene + "\n"
        fstr += "aa: " + self.aa + "\n"
        fstr += "nuc: " + self.nuc + "\n"
        fstr += "codon: " + self.original_codon + ">" + self.alternative_codon + "\n"
        return fstr

def _generate_translations(transtr):
    """
    Convert an amino acid translation string to a list containing AAChange objects.
    """
    #do nothing if an empty string is passed.    
    aachanges = []
    if transtr != "":
        #process the transtr in relevant pieces
        aagenes, nucs, codons = [v.split(";") for v in transtr.split('\t')]
        assert len(aagenes) == len(nucs)
        for i in range(len(aagenes)):
            gene, aa = aagenes[i].split(":")
            #sometimes two adjacent nucleotide mutations contribute to the same amino acid change, making them annoying to store correctly
            #make a copy of the change in another class object even though there's only one actual amino acid change here. Edge case to keep an eye on.
            mnucs = nucs[i].split(",")
            for mn in mnucs:
                aachanges.append(AAChange(gene, aa, mn, codons[i]))
    return aachanges

cdef class MATNode:
    """
    A wrapper around the MAT node class. Has an identifier, mutations, parent, and child attributes.
    """
    cdef bte.Node* n

    def __init__(self, tree: MATree = None, parent: Optional[str] = None, identifier: str = "", mutations: list = [], annotations: list = [], branch_length: float = 0.0):
        """
        Initalize a MATNode and an associated Node and add it to the tree as a child of the indicated Node.
        Can optionally have mutations loaded as well. By default, creates a MATNode wrapper with no associated Node.

        args:
            tree (MATree): MATree object to add the node to.

            parent (str): The identifier of the parent Node.

            identifier (str): The identifier to use for the Node. Must be unique.

            mutations (list[str]): A list of mutations to apply to the Node. Optional.

            annotations (list[str]): A list of annotations to apply to the Node. Optional.

            branch_length (float): The length of the branch as a float. Optional; if not set, will be equal to the length of the mutations list.
        """
        if tree != None and identifier != "" and parent != None:
            if branch_length == 0:
                branch_length = len(mutations)
            tree.create_node(identifier, parent, mutations, annotations, branch_length)
            self.n = tree.t.get_node(identifier.encode("UTF-8"))

    cdef from_node(self, bte.Node* n):
        """"
        Load a node object from a MAT node. Attributes specific to the node such as mutations and identifier
        will be loaded automatically into python attributes and relational attributes to other nodes can be accessed through fetch methods 
        to the C++ class attributes.
        """
        if n == cython.NULL:
            raise ValueError("Target node is null- check that your node exists and that you're not taking the parent of the root node.")
        self.n = n
        return self

    def is_leaf(self):
        """
        Returns true if the node is a leaf node.
        """
        return self.n.is_leaf()

    @property
    def level(self):
        return self.n.level

    @property
    def id(self):
        return self.n.identifier.decode("UTF-8")

    @property
    def parent(self):
        pn = MATNode()
        if self.n.parent != cython.NULL:
            pn.from_node(self.n.parent)
            return pn
        else:
            return None

    @property
    def children(self):
        cnv = []
        for n in self.n.children:
            cn = MATNode()
            cn.from_node(n)
            cnv.append(cn)
        return cnv

    @property
    def mutations(self):
        return [m.get_string().decode("UTF-8") for m in self.n.mutations]

    def get_mutation_information(self) -> list[dict[str,str]]:
        """
        Print full attribute information for each mutation associated with this node, including chromosome, location, parent, reference, and alternative nucleotides.

        Returns:
            list[dist[str,str]]: List of dictionaries containing keyed attribute information.
        """
        outv = []
        for m in self.n.mutations:
            md = {}
            md['chrom'] = m.chrom.decode("UTF-8")
            md['position'] = m.position
            md['ref_nuc'] = chr(bte.get_nuc(m.ref_nuc))
            md['par_nuc'] = chr(bte.get_nuc(m.par_nuc))
            md['mut_nuc'] = chr(bte.get_nuc(m.mut_nuc))
            outv.append(md)
        return outv

    @property
    def annotations(self):
        return [a.decode("UTF-8") for a in self.n.clade_annotations]

    @property
    def branch_length(self):
        return self.n.branch_length

    def set_branch_length(self, blen: float):
        """Set the branch length for this node to the input float value.

        args:
            blen (float): Set the branch length to this value.
        """
        self.n.branch_length = blen

    def most_recent_annotation(self) -> list[str]:
        """Find the most recent clade annotations for the node in the node's ancestry.

        Returns:
            A list of annotation strings.
        """      
        cdef bte.Node* ancestor = self.n
        cdef size_t anncount = self.n.clade_annotations.size()
        cdef vector[string] annotes 
        cdef size_t k
        annotations = [None for i in range(anncount)]
        while any([a==None for a in annotations]):
            annotes = ancestor.clade_annotations
            for k in range(annotes.size()):
                if annotes[k].size() > 0 and (annotations[k] == None):
                    annotations[k] = annotes[k].decode("UTF-8")
            if ancestor.parent == cython.NULL:
                break
            ancestor = ancestor.parent
        return annotations

    def update_mutations(self, mutation_list: list[str], update_branch_length: bool = True):
        """Take a list of mutations as strings and replace any currently stored mutations on this branch with the new set.
        Mutation strings should be formatted as chro:reflocalt e.g. chr1:A234G. If chromosome is left off, assumes SARS-CoV-2 chromosome.

        Args:
            mutation_list (list[str]): List of mutations to store.
            update_branch_length (bool): Update the branch length attribute to the new count of mutations. Default is True.
        """        
        self.n.mutations.clear()
        cdef bte.Mutation newmut
        for mstr in mutation_list:
            newmut = instantiate_mutation(mstr)
            self.n.mutations.push_back(newmut)
        if update_branch_length:
            self.n.branch_length = len(mutation_list)

    def __repr__(self):
        fstr = ""
        fstr += "id: " + self.id + "\n"
        fstr += "level: " + str(self.level) + "\n"
        if self.n.parent != cython.NULL:
            fstr += "parent: " + self.parent.id + "\n"
        else:
            fstr += "parent: None\n"
        fstr += "children: " + str([c.id for c in self.children]) + "\n"
        fstr += "mutations: " + str(self.mutations) + "\n"
        fstr += "annotations: " + str(self.annotations) + "\n"
        fstr += "branch length: " + str(self.branch_length) + "\n"
        return fstr

cdef complement(int8_t input):
    if input == 0b1:
        return 0b1000
    elif input == 0b1000:
        return 0b1
    elif input == 0b10:
        return 0b100
    elif input == 0b100:
        return 0b10
    else:
        return input

cdef class MATree:
    """
    A wrapper around the MAT Tree class. Includes functions to save and load from parsimony .pb files or a newick. Includes 
    numerous functions for tree traversal including breadth-first, depth-first, and traversal from leaf to roots. Also includes
    numerous functions for subtree selection by choosing leaves that match regex patterns, contain specific mutations, or 
    are from a specific clade or lineage.
    """
    cdef bte.Tree t
    cdef public cbool _tree_only
    cdef public cbool _empty

    @_timer
    def __init__(self, pb_file: Optional[str] = None, uncondense: bool = True, nwk_file: Optional[str] = None, nwk_string: Optional[str] = None, vcf_file: Optional[str] = None, json_file: Optional[str] = None) -> None:
        """Instantiate a MATree object.

        Args:
            pb_file (Optional[str], optional): Load from a protobuf. Defaults to None.

            uncondense (bool, optional): Uncondense after loading from a protobuf. Defaults to True.
            
            nwk_file (Optional[str], optional): Load from a text file containing a newick representation of a tree. Defaults to None.
            
            nwk_string (Optional[str], optional): Load from a Python string newick. Defaults to None.
            
            vcf_file (Optional[str], optional): Load genotype information for leaves from a vcf. Defaults to None.
            
            json_file (Optional[str], optional): Load a complete tree from an Auspice-format JSON. Defaults to None.

        Raises:
            Exception: Invalid file type.

            Exception: Loading from VCF without a newick.
        """
        self._tree_only = False
        self._empty = False
        if pb_file != None:
            if not exists(pb_file):
                raise Exception("Input file not found!")
            if nwk_file != None or vcf_file != None or nwk_string != None:
                print("WARNING: nwk_file, nwk_string and vcf_file arguments are exclusive with pb_file. Ignoring",file=sys.stderr)
            if pb_file[-3:] == ".pb" or pb_file[-6:] == ".pb.gz":
                self.from_pb(pb_file,uncondense)
            else:
                raise Exception("Invalid file extension for pb_file argument. Must be .pb or .pb.gz")
        elif json_file != None:
            if not exists(json_file):
                raise Exception("Input json file not found!")
            self.from_json(json_file)
        elif nwk_string != None:
            if vcf_file != None:
                if not exists(vcf_file):
                    raise Exception("Input vcf file not found!")
                print("WARNING: nwk_string is for tree-only loading and does not use vcf input. Consider using nwk_file.",file=sys.stderr)
            self.t = bte.create_tree_from_newick_string(nwk_string.encode("UTF-8"))
            self._tree_only = True
        else:
            if nwk_file != None:
                if not exists(nwk_file):
                    raise Exception("Input newick file not found!")
                if vcf_file == None:
                    self.t = bte.create_tree_from_newick(nwk_file.encode("UTF-8"))
                    self._tree_only = True
                else:
                    if not exists(vcf_file):
                        raise Exception("Input vcf file not found!")
                    self.from_newick_and_vcf(nwk_file,vcf_file)
            elif vcf_file != None:
                raise Exception("Loading from VCF requires a newick file.")
            else:
                # self.t = bte.Tree()
                print("No input arguments passed; creating default tree.")
                #pass a minimal newick. This is loaded as a root and a single child.
                self.t = bte.create_tree_from_newick_string("();".encode("UTF-8"))
    
    def __repr__(self):
        return "MATree object with " + str(self.t.get_num_leaves(self.t.root)) + " leaves."

    def clear(self) -> None:
        """
        Call this function to explicitly deallocate all tree memory. Use when the tree object is no longer necessary 
        and high memory use is becoming problematic. Automatically called on garbage collection.
        """
        cdef vector[Node*] nodes 
        if not self._empty:
            nodes = self.t.depth_first_expansion(self.t.root)
            for i in range(nodes.size()):
                nodes[i].mutations.clear()
            bte.clear_tree(self.t)
            self._empty = True

    def __del__(self):
        self.clear()

    @staticmethod
    def _check_newick_only(func, *args, **kwargs):
        """
        Decorator function applied to class functions which require mutations to exist on the tree. 
        A tree loaded from a newick alone will be unable to apply these functions and this decorator serves
        as a readable way to add checks to these functions.
        """
        @functools.wraps(func)
        def wrap(self, *args, **kwargs):
            if self._tree_only:
                raise Exception("Tree does not contain explicit mutation information and this function cannot be used. You can add mutations with apply_mutations or load from a vcf or pb.")
            else:
                return func(self, *args,**kwargs)
        return wrap

    def apply_mutations(self, mmap: dict[str,list[str]], update_branch_length: bool = True) -> None:
        """Pass a set of node:mutation mappings to place into the tree. Current mutations will be replaced.

        Args:
            mmap (dict[str,list[str]]): A dictionary of node:mutation list mappings (e.g. {"node_id":["chro:reflocalt","chro:reflocalt"]}, {"node_1":["chro1:A123G","chro3:T315G"]}
            update_branch_length (bool): Update the branch length to match the new count of mutations on each node. Defaults to True.
        """
        for nid, nms in mmap.items():
            node = self.get_node(nid)
            node.update_mutations(nms, update_branch_length)
        #the tree is now annotated with mutations and mutation-based functions can be attempted.
        self._tree_only = False

    cdef uncondense(self):
        self.t.uncondense_leaves()

    cdef condense(self):
        self.t.condense_leaves([])

    cdef assign_tree(self, bte.Tree t):
        self.t = t

    cdef resolve_all_polytomies(self):
        self.t = resolve_all_polytomies(self.t)

    @_timer
    def from_pb(self, file: str, uncondense: bool = True) -> None:
        """Load from a protobuf into the initalized wrapper. Includes both tree and mutation information.

        Args:
            file (str): Path to a .pb or .pb.gz file.

            uncondense (bool, optional): Uncondense the tree after loading (split identical samples into individual leaves). Defaults to True.
        """
        cdef string fn = file.encode("UTF-8")
        cdef bte.Tree lt
        with nogil:
            lt = bte.load_mutation_annotated_tree(fn)
        self.t = lt
        if uncondense:
            self.uncondense()
        self._tree_only = False

    @_timer    
    def from_newick_and_vcf(self, nwk: str, vcf: str) -> None:
        """Load from a newick and a vcf. The vcf must contain sample entries (genotype columns) for every leaf in the newick.

        Args:
            nwk (str): Path to a text file containing the tree to load in Newick format.

            vcf (str): Path to a text file containing leaf/sample genotype information in VCF format.
        """
        self.t = bte.create_tree_from_newick(nwk.encode("UTF-8"))
        cdef vector[Missing_Sample] missing
        bte.read_vcf(&self.t,vcf.encode("UTF-8"),missing,True)
        self._tree_only = False

    def save_pb(self, file: str, condense: bool = True) -> None:
        """Save the tree to a protobuf file. If the filename ends in '.pb.gz', it will be gzipped automatically.

        Args:
            file (str): Name for the .pb/.pb.gz file.

            condense (bool, optional): Condense the tree before saving. Defaults to True.
        """        
        if condense:
            self.condense()
        bte.save_mutation_annotated_tree(self.t,file.encode("UTF-8"))
        #uncondense again afterwards if it was condensed for saving.
        if condense:
            self.uncondense()

    @_timer
    def from_newick(self, nwk_file: str) -> None:
        """Load from a newick file only. The resulting tree will lack mutation information, preventing some functions from being applied.

        Args:
            nwk_file (str): Path to a text file containing a newick representation of the tree.
        """        
        self.t = bte.create_tree_from_newick(nwk_file.encode("UTF-8"))
        self._tree_only = True

    def from_newick_string(self, nwk: str) -> None:
        """Load from a Python string newick. The resulting tree will lack mutation information, preventing some functions from being applied.

        Args:
            nwk (str): A Python string containing a newick representation of the tree.

        """        
        self.t = bte.create_tree_from_newick_string(nwk.encode("UTF-8"))
        self._tree_only = True

    def get_newick(self, subroot: Optional[str] = None, print_internal: bool = True, print_branch_len: bool = True, retain_original_branch_len: bool = True, uncondense_leaves: bool = True) -> str:
        """Extract a newick string from the tree.

        Args:
            subroot (Optional[str], optional): Return a newick representing the subtree descended from this node. Defaults to the root.

            print_internal (bool, optional): Include internal node names in the newick output. Defaults to True.

            print_branch_len (bool, optional): Include branch lengths in the newick output. Defaults to True.

            retain_original_branch_len (bool, optional): Retain the original branch length attribute, if one was provided. Defaults to True.

            uncondense_leaves (bool, optional): Uncondense nodes before returning the newick. Defaults to True.

        Returns:
            str: A newick string representation of the tree.
        """        
        cdef stringstream ss
        cdef Node* sr
        if subroot == None:
            sr = self.t.root
        else:
            se = self.t.get_node(subroot.encode("UTF-8"))
        bte.write_newick_string(ss,self.t,sr,print_internal,print_branch_len,retain_original_branch_len,uncondense_leaves)
        return ss.to_string().decode("UTF-8")

    def write_newick(self, file: str, subroot: Optional[str] = None, print_internal: bool = True, print_branch_len: bool = True, retain_original_branch_len: bool = True, uncondense_leaves: bool = True):
        """Print a newick string representing the tree/subtree to the target file.

        Args:
            file (str): Name of the file to write the newick to.

            subroot (Optional[str], optional): Write a newick representing the subtree descended from this node. Defaults to the root.

            print_internal (bool, optional): Include internal node names in the newick output. Defaults to True.

            print_branch_len (bool, optional): Print branch lengths. Defaults to True.

            retain_original_branch_len (bool, optional): Retain the original branch length attribute, if one was provided. Defaults to True.

            uncondense_leaves (bool, optional): Uncondense nodes before writing the newick. Defaults to True.
        """
        with open(file,'w+') as of:
            of.write(self.get_newick(subroot, print_internal, print_branch_len, retain_original_branch_len, uncondense_leaves))

    cpdef vector[string] _read_samples(self,samples):
        """Helper function which converts a Python list of bytes or string samples to a usable C++ string vector.
        Returns all leaf names if samples is empty.
        """
        cdef vector[string] sample_names
        if len(samples) == 0:
            sample_names = self.t.get_leaves_ids(b"")
        else:
            for s in samples:
                if type(s) == str:
                    sample_names.push_back(s.encode("UTF-8"))
                elif type(s) == bytes:
                    sample_names.push_back(s)
                else:
                    raise Exception("Sample names must be strings or bytes.")
        return sample_names

    def write_vcf(self, vcf_file: str , no_genotypes: bool = False, samples: list[str] = []) -> None:        
        """Write a vcf representing the chosen samples to the indicated file. By default, writes a vcf including all samples.

        Args:
            vcf_file (str): Name the output vcf file.

            no_genotypes (bool, optional): Do not include individual genotype information in the output vcf. Defaults to False.

            samples (list[str], optional): Samples to include. Defaults to all samples.
        """        
        sample_names = self._read_samples(samples)
        bte.make_vcf(self.t,vcf_file.encode("UTF-8"),no_genotypes,sample_names)

    def from_json(self, jsonf: str) -> None:
        """Load a mat from a json compatible with the Auspice.us visualization web tool.

        Args:
            jsonf (str): Path to a json file.
        """        
        self.t = bte.load_mat_from_json(jsonf.encode("UTF-8"))

    def write_json(self, jsonf: str, samples: list[str] = [], title: str = "Tree", metafiles: list[str] = []) -> None:
        """Write a json compatible with the Auspice.us visualization web tool containing the indicated samples. Default behavior includes the whole tree.
        You can optionally pass a tsv or csv file or a list of tsv and csv files containing categorical metadata to decorate the json with (one sample per row).

        Args:
            jsonf (str): Name for the JSON output.

            samples (list, optional): Samples to use. Defaults to all samples.

            title (str, optional): Title of the JSON. Defaults to "Tree".

            metafiles (list, optional): Metadata tsv and csv files to use. Defaults to no metadata.
        """
        cdef vector[string] sample_names = self._read_samples(samples)
        cdef cset[string] sample_set
        for i in range(sample_names.size()):
            sample_set.insert(sample_names[i])
        cdef vector[unordered_map[string,unordered_map[string,string]]] catmeta
        if type(metafiles) == str:
            catmeta.push_back(bte.read_metafile(metafiles.encode("UTF-8"),sample_set))
        elif type(metafiles) == list and len(metafiles) > 0:
            for mf in metafiles:
                catmeta.push_back(bte.read_metafile(mf.encode("UTF-8"),sample_set))
        cdef bte.Tree subtree
        with nogil:
            subtree = bte.filter_master(self.t, sample_names, False, True)
        if subtree.get_num_leaves(subtree.root) == 0:
            print("ERROR: Unable to find samples to extract json! Check sample input")
            sys.exit(1)
        bte.write_json_from_mat(&subtree,jsonf.encode("UTF-8"),&catmeta,title.encode("UTF-8"))

    def get_parsimony_score(self) -> int:
        """
        Compute the parsimony score of the complete tree.

        Returns:
            int: The parsimony score of the tree.
        """
        return self.t.get_parsimony_score()

    def get_node(self, name: str) -> MATNode:
        """Create a MATNode class object representing the indicated node.

        Args:
            name (str): ID of the node to fetch.

        Returns:
            MATNode: MATNode class object representing the indicated node.s
        """
        nc = MATNode()
        nc.from_node(self.t.get_node(name.encode("UTF-8")))
        return nc

    @property
    def root(self) -> MATNode:
        """Retrieve the root of the tree.

        Returns:
            MATNode: MATNode wrapper representing the root node of the tree.
        """        
        nc = MATNode()
        nc.from_node(self.t.root)
        return nc

    cdef dfe_helper(self, bte.Node* node, cbool reverse):
        pynvec = []
        cdef vector[bte.Node*] nvec = self.t.depth_first_expansion(node)
        for i in range(nvec.size()):
            nodec = MATNode()
            nodec.from_node(nvec[i])
            pynvec.append(nodec)
        if reverse:
            pynvec.reverse()
        return pynvec

    def depth_first_expansion(self, nid: Optional[str] = None, reverse: bool = False) -> list[MATNode]:
        """Perform a preorder (depth-first) expansion of the tree, starting from the indicated node. 
        By default, traverses the whole tree. Set reverse to true to traverse in postorder (reverse depth-first) instead.

        Args:
            nid (Optional[str], optional): Node to begin the traversal at. Defaults to the root.

            reverse (bool, optional): Traverse in reverse order. Defaults to False.

        Returns:
            list[MATNode]: List of nodes in depth-first order.
        """        

        if nid == None:
            return self.dfe_helper(self.t.root, reverse)
        else:
            return self.dfe_helper(self.t.get_node(nid.encode("UTF-8")), reverse)

    def get_leaves(self, nid: str = "") -> list[MATNode]:
        """Create a list of MATNode objects representing each leaf descended from the indicated node. By default, returns all leaves on the tree.

        Args:
            nid (str, optional): Node to get leaves descended from. Defaults to the root.

        Returns:
            list[MATNode]: List of MATNode wrappers representing all leaves.
        """        
        cdef vector[Node*] leaves = self.t.get_leaves(nid.encode("UTF-8"))
        wrappers = []
        for i in range(leaves.size()):
            nodec = MATNode().from_node(leaves[i])
            wrappers.append(nodec)
        return wrappers

    def get_leaves_ids(self, nid: str = "") -> list[str]:
        """Return a list of leaf name strings containing all leaves descended from the indicated node. By default, returns all leaves on the tree.

        Args:
            nid (str, optional): Node to get the descendents of. Defaults to the root.

        Returns:
            list[str]: List of leaf names.
        """
        cdef vector[string] leaves = self.t.get_leaves_ids(nid.encode("UTF-8"))
        names = []
        for i in range(leaves.size()):
            names.append(leaves[i].decode("UTF-8"))
        return names

    cdef bfe_helper(self, string nid, cbool reverse):
        pynvec = []
        cdef vector[bte.Node*] nvec = self.t.breadth_first_expansion(nid)
        for i in range(nvec.size()):
            nodec = MATNode()
            nodec.from_node(nvec[i])
            pynvec.append(nodec)
        if reverse:
            pynvec.reverse()
        return pynvec

    def breadth_first_expansion(self, nid: str = "", reverse: bool = False) -> list[MATNode]:
        """Perform a level order (breadth-first) expansion starting from the indicated node. Use reverse to traverse in reverse level order (all leaves, then all leaf parents, back to root) instead.

        Args:
            nid (str, optional): Node to begin the traversal at. Defaults to the root.

            reverse (bool, optional): Perform the traversal in reverse. Defaults to False.

        Returns:
            list[MATNode]: List of MATNode wrappers representing the nodes in the traversal.
        """        
        return self.bfe_helper(nid.encode("UTF-8"),reverse)

    cdef rsearch_helper(self, string nid, cbool include_self, cbool reverse):
        pynvec = []
        cdef vector[bte.Node*] nvec = self.t.rsearch(nid,include_self)
        for i in range(nvec.size()):
            nodec = MATNode()
            nodec.from_node(nvec[i])
            pynvec.append(nodec)
        return pynvec

    def rsearch(self, nid: str, include_self: bool = False,reverse: bool = False) -> list[MATNode]:
        """Return a list of MATNode objects representing the ancestors of the indicated node back to the root in order from the node to the root.

        Args:
            nid (str): ID of the node to get the ancestry of.

            include_self (bool, optional): Include the indicated node on the path. Defaults to False.

            reverse (bool, optional): Return the path in reverse order. Defaults to False.

        Returns:
            list[MATNode]: A list of ancestors of the indicated node.
        """ 
        return self.rsearch_helper(nid.encode("UTF-8"),include_self,reverse)

    cdef get_subtree(self, vector[string] samples):
        cdef bte.Tree subtree
        with nogil:
            subtree = bte.filter_master(self.t, samples, False, True)
        subt = MATree()
        subt.assign_tree(subtree)
        return subt

    @_timer    
    def subtree(self, samples: list[Union[str,bytes]]) -> MATree:
        """Retrieve a subtree containing all samples in the input list.

        Args:
            samples (list[Union[str,bytes]]): List of sample names to include in the subtree. Can be bytes or str.

        Returns:
            MATree: the subtree containing all samples in the input list.
        """        
        cdef vector[string] samples_vec = self._read_samples(samples)
        return self.get_subtree(samples_vec)

    cpdef vector[string] get_clade_samples(self, clade_id):
        """Return samples from the selected clade.

        Args:
            clade_id (str): Clade to find.

        Returns:
            list[bytes]: List of sample IDs which are members of the indicated clade.
        """
        cdef vector[string] samples = bte.get_clade_samples(&self.t, clade_id.encode("UTF-8"))
        return samples

    def get_clade(self, clade_id: str) -> MATree:
        """Return a subtree representing the selected clade.

        Args:
            clade_id (str): The clade to retrieve.

        Returns:
            MATree: the subtree representing that clade.
        """
        print("Getting clade: " + clade_id,file=sys.stderr)
        cdef vector[string] samples = self.get_clade_samples(clade_id)
        if samples.size() == 0:
            print("Error: requested clade not found.",file=sys.stderr)
            return None
        print("Successfully found {} samples.".format(len(samples)),file=sys.stderr)
        return self.get_subtree(samples)

    cpdef vector[string] get_regex_samples(self, regexstr: str):
        """Return a list of sample IDs on the tree which match the regular expression.

        Args:
            regexstr (str): The regex pattern to match.

        Returns:
            list[bytes]: List of sample IDs.
        """        
        #the C++ allows for a preselection of samples, but we don't use that option.
        cdef vector[string] to_check = []
        cdef vector[string] samples = bte.get_sample_match(&self.t, to_check, regexstr.encode("UTF-8"))
        return samples
    
    def get_regex(self, regexstr: str) -> MATree:
        """Return a subtree representing all samples matching the regular expression.

        Args:
            regexstr (str): The regular expression to use to query the tree.

        Returns:
            MATree: Subtree containing samples matching the regex.
        """
        cdef vector[string] samples = self.get_regex_samples(regexstr)
        if samples.size() == 0:
            print("Error: requested regex does not match any samples.",file=sys.stderr)
            return None
        print("Successfully found {} samples.".format(len(samples)),file=sys.stderr)
        return self.get_subtree(samples)

    def get_random(self, size: int, current_samples: list = [], lca_limit: bool = False) -> MATree:
        """Select a random subtree of the selected size. Optionally, pass a list of samples to include.
        If the list of samples to include is larger than the target size, random samples will be removed from the list.
        Set lca_limit to True to limit random selection to below the common ancestor of the current selection.
        Selects as many as possible if not enough are available.

        Args:
            size (int): The size of the subtree to select.

            current_samples (list, optional): List of samples to include in the set. Defaults to [].
            
            lca_limit (bool, optional): Limit randomly selected samples to below the LCA of the input samples. Defaults to False.

        Returns:
            MATree: A subtree containing the selected samples.
        """        
        if len(current_samples) == 0 and lca_limit:
            Exception("LCA limit requires a selection of samples to be passed in.")
        cdef vector[string] starting_samples = current_samples
        cdef size_t target_size = size
        cdef bool lcal = lca_limit
        cdef vector[string] final_samples = bte.fill_random_samples(&self.t, starting_samples, target_size, lcal)
        return self.get_subtree(final_samples)

    cpdef vector[string] get_mutation_samples(self, mutation):
        """Return samples with genotypes containing the selected mutation.

        Args:
            mutation (str): string representation of the mutation in reflocalt format (e.g. "A123C").

        Returns:
            list[bytes]: samples with the mutation.
        """    
        #can't use the error decorator for this function since it is cpdef.
        if self._tree_only:
            Exception("Cannot find mutations on a tree-only MATree.")
        cdef vector[string] samples = bte.get_mutation_samples(&self.t, mutation.encode("UTF-8"))
        return samples

    @_check_newick_only
    def get_mutation(self, mutation: str) -> MATree:
        """Return a subtree containing samples with genotypes containing the indicated mutation.

        Args:
            mutation (str): string representation of the mutation in reflocalt format (e.g. "A123C").

        Returns:
            MATree: subtree containing samples with the mutation.
        """        
        cdef vector[string] samples = self.get_mutation_samples(mutation)
        return self.get_subtree(samples)

    @_check_newick_only
    def count_mutation_types(self, subroot: Optional[str] = None) -> dict[str,int]:
        """Compute the counts of individual mutation types across the tree. If a subtree root is indicated, it only counts mutations
        descended from that node. By default, this counts across the entire tree.

        Args:
            subroot (Optional[str], optional): Count mutations descended from the indicated node. Defaults to the root.

        Returns:
            dict[str,int]: Dictionary containing mutation counts.
        """
        mcount = {}
        cdef Node* target_n = self.t.root
        if subroot != None:
            target_n = self.t.get_node(subroot.encode("UTF-8"))
        cdef vector[Node*] nvec = self.t.depth_first_expansion(target_n)
        for i in range(nvec.size()):
            for m in nvec[i].mutations:
                pym = m.get_string().decode("UTF-8")
                pym_type = pym[0] + ">" + pym[-1]
                if pym_type in mcount:
                    mcount[pym_type] += 1
                else:
                    mcount[pym_type] = 1
        return mcount

    def count_leaves(self, subroot: Optional[str] = None) -> int:
        """Return the number of leaves descended from the indicated node. By default, counts all leaves on the tree.

        Args:
            subroot (Optional[str], optional): Count leaves descended from the indicated node. Defaults to the root.

        Returns:
            int: The count of leaves.
        """        
        cdef Node* target_n = self.t.root
        if subroot != None:
            target_n = self.t.get_node(subroot.encode("UTF-8"))
        return self.t.get_num_leaves(target_n)

    cdef cset[bte.Mutation] accumulate_mutations(self, string sample):
        cdef vector[bte.Node*] ancestors = self.t.rsearch(sample, True)
        cdef cset[bte.Mutation] allm
        cdef cset[bte.Mutation].iterator allm_iter
        cdef size_t i
        cdef bte.Node* cnode
        cdef bte.Mutation m, om
        cdef cset[bte.Mutation].iterator oml
        cdef size_t ancs = ancestors.size()
        for i in range(ancs):
            #proceed in reverse order e.g. root to sample.
            cnode = ancestors[ancs-i-1]
            for j in range(cnode.mutations.size()):
                m = cnode.mutations[j]
                fresh = True
                allm_iter = allm.begin()
                while allm_iter != allm.end():
                    om = dereference(allm_iter)
                    if (m.chrom == om.chrom) and (m.position == om.position):
                        fresh = False
                        #instead of inserting this mutation anew, update the old one.
                        #if they're opposite, they negate to prevent a mutation from something to itself.
                        if m.mut_nuc == om.par_nuc:
                            allm.erase(allm_iter)
                        else:
                            om.mut_nuc = m.mut_nuc
                        break
                    postincrement(allm_iter)
                if fresh:
                    allm.insert(m)
        return allm

    def mutation_set(self, nid: str) -> set[str]:
        """Return the complete set of mutations (haplotype) the indicated node has with respect to the reference. 
        DEPRECATED in favor of get_haplotype, which is equivalent functionally.

        Args:
            nid (str): The target node to get the haplotype for.

        Returns:
            set[str]: the haplotype of the node, represented as a set of mutations formatted in reflocalt (e.g. A123G) format.
        """
        #Deprecated; use get_haplotype instead.
        print("WARNING: mutation_set is deprecated. Use get_haplotype instead, which has the same functionality.", file=sys.stderr)
        return self.get_haplotype(nid)

    @_check_newick_only
    def get_haplotype(self, nid: str) -> set[str]:
        """Return the complete set of mutations (haplotype) the indicated node has with respect to the reference. 

        Args:
            nid (str): The target node to get the haplotype for.

        Returns:
            set[str]: the haplotype of the node, represented as a set of mutations formatted in reflocalt (e.g. A123G) format.
        """
        pyset = set()
        cdef cset[bte.Mutation] accm = self.accumulate_mutations(nid.encode("UTF-8"))
        cdef cset[bte.Mutation].iterator accm_it = accm.begin()
        while accm_it != accm.end():
            pyset.add(dereference(accm_it).get_string().decode('UTF-8'))
            postincrement(accm_it)
        return pyset

    cdef count_differences(self, cset[bte.Mutation] l1, cset[bte.Mutation] l2):
        cdef size_t total_matched = 0
        cdef bte.Mutation e1
        cdef cset[bte.Mutation].iterator it = l1.begin()
        while it != l1.end():
            e1 = dereference(it)
            if l2.find(e1) != l2.end():
                total_matched += 1
            postincrement(it)
        return l1.size() + l2.size() - (total_matched * 2)

    cdef map[cset[bte.Mutation],size_t] count_haplotypes_c(self):
        '''
        Return a dictionary of unique haplotypes and their counts. Used for nucleotide diversity estimates.
        '''
        cdef vector[string] samples = self.t.get_leaves_ids("".encode("UTF-8"))
        cdef map[cset[bte.Mutation],size_t] divtrack
        cdef map[cset[bte.Mutation],size_t].iterator finder
        cdef size_t i
        cdef cset[bte.Mutation] accum_muts
        for i in range(samples.size()):
            accum_muts = self.accumulate_mutations(samples[i])
            finder = divtrack.find(accum_muts)
            if finder == divtrack.end():
                divtrack[accum_muts] = 1
            else:
                divtrack[accum_muts] = dereference(finder).second + 1
        return divtrack

    def count_clades_inclusive(self, subroot: str = "") -> dict[str,int]:
        """Count the total number of leaves belonging to each clade on the subtree.
        Counts are inclusive (e.g. samples belonging to a clade descended from another clade will count for the ancestor clade as well)
        By default, counts across the whole tree.

        Args:
            subroot (str, optional): Count members of clades descended from this node. Defaults to the root.

        Returns:
            dict[str,int]: Dictionary containing clade counts.
        """
        cdef vector[string] leaves = self.t.get_leaves_ids(subroot.encode("UTF-8"))
        cdef size_t i,j,k
        cdef vector[bte.Node*] ancestors
        cdef vector[string] canns
        cdef string ann
        clade_counts = {}
        for i in range(leaves.size()):
            ancestors = self.t.rsearch(leaves[i], True)
            for j in range(ancestors.size()):
                canns = ancestors[j].clade_annotations
                for k in range(canns.size()):
                    ann = canns[k]
                    if ann.size() > 0:
                        annstr = ann.decode("UTF-8")
                        if annstr not in clade_counts:
                            clade_counts[annstr] = 0
                        clade_counts[annstr] += 1
        return clade_counts

    @_check_newick_only    
    def count_haplotypes(self) -> dict[tuple,int]:
        """Count unique haplotypes from the tree.

        Returns:
            dict[tuple,int]: haplotype counts.
        """
        cdef map[cset[bte.Mutation],size_t] hmap = self.count_haplotypes_c()
        cdef map[cset[bte.Mutation],size_t].iterator it = hmap.begin()
        cdef cset[bte.Mutation].iterator it2
        pymap = {}
        while it != hmap.end():
            mset = set()
            it2 = dereference(it).first.begin()
            while it2 != dereference(it).first.end():
                mset.add(dereference(it2).get_string())
                postincrement(it2)
            pymap[tuple(mset)] = dereference(it).second
            postincrement(it)
        return pymap

    @_check_newick_only
    def compute_nucleotide_diversity(self) -> float:
        """Function which computes the nucleotide diversity of the tree. This is defined as the mean number of pairwise differences in nucleotides between any two leaves
        of the tree. Computes an unbiased estimator which multiplies the final mean by the total number of sequences divided by the total number of sequences minus one.

        Raises:
            Exception: Can't be computed on an empty tree.

        Returns:
            float: The estimated nucleotide diversity.
        """        
        #compute the set of mutations belonging to each sample in the tree, then compute pi from the resulting frequencies
        #since each sample is individually rsearched, this implementation is less efficient than an informed traversal, but still fast enough for most purposes.
        cdef map[cset[bte.Mutation],size_t] divtrack = self.count_haplotypes_c()
        cdef size_t total_seq = self.t.get_leaves_ids(self.t.root.identifier).size()
        if total_seq == 0:
            raise Exception("No sequences found in tree")
        cdef double div = 0
        cdef map[cset[bte.Mutation],size_t].iterator it = divtrack.begin()
        cdef map[cset[bte.Mutation],size_t].iterator it2
        cdef double g1_freq, g2_freq
        cdef size_t pair_diff
        while it != divtrack.end():
            g1_freq = dereference(it).second / total_seq
            assert g1_freq > 0
            it2 = it
            postincrement(it2)
            while it2 != divtrack.end():
                g2_freq = dereference(it2).second / total_seq
                assert g2_freq > 0
                pair_diff = self.count_differences(dereference(it).first,dereference(it2).first)
                div = div + (g1_freq * g2_freq * pair_diff)
                postincrement(it2)
            postincrement(it)
        #multiply the final result to guarantee an unbiased estimator (see wikipedia entry)
        return div * (total_seq / (total_seq - 1))

    def simple_parsimony(self, leaf_assignments: dict[str,str]) -> dict[str,str]:
        """This function is an implementation of the small parsimony problem (Fitch algorithm) for a single set of states.
        It takes as input a dictionary mapping leaf names to character states and returns a dictionary mapping both leaf and internal node names to inferred character states.

        Args:
            leaf_assignments (dict[str,str]): Dictionary mapping leaf names to character states.

        Returns:
            dict[str,str]: Dictionary mapping node names to inferred character states.
        """        
        ##TODO: refactoring this to use more c types would increase efficiency notably. It's fairly niche in application, though.
        #this algorithm traverses the tree in postorder (reverse depth-first)
        #it requires that the tree be fully resolved and bifurcating, so that's the first step.
        #note on efficiency- we're using Python dicts to do most of the set logic, which are slower than using native C++ objects
        print("Resolving polytomies...",file=sys.stderr)
        self.resolve_all_polytomies()
        #initialize node assignments with leaf states
        node_assignment_set = {l:set(v) for l,v in leaf_assignments.items()}
        print("{} initial assignments".format(len(node_assignment_set)),file=sys.stderr)
        #first, a postorder traversal. We implement this here by generating nodes in depth-first order and proceeding 
        #to iterate through their indeces in reverse.
        cdef vector[Node*] nodes = self.t.depth_first_expansion(self.t.root)
        cdef Node* cnode
        cdef vector[Node*] children
        cdef size_t i
        for i in range(nodes.size()):
            cnode = nodes[nodes.size()-i-1]
            if not cnode.is_leaf():
                #if it is correctly resolved, this node will have exactly two children.
                children = cnode.children
                assert children.size() == 2
                left = node_assignment_set[children[0].identifier.decode("UTF-8")]
                right = node_assignment_set[children[1].identifier.decode("UTF-8")]
                state = left & right
                if not state:
                    state = left | right
                node_assignment_set[cnode.identifier.decode("UTF-8")] = state
        #we then traverse again through the same sets of nodes in preorder/depth-first, finalizing character states based on 
        #the state of the parent.
        assert len(node_assignment_set) == nodes.size()
        final_node_assignment = leaf_assignments
        cdef Node* parent
        for i in range(nodes.size()):
            cnode = nodes[i]
            if not cnode.is_leaf():
                current_state = node_assignment_set[cnode.identifier.decode("UTF-8")]
                if len(current_state) == 1:
                    final_node_assignment[cnode.identifier.decode("UTF-8")] = list(current_state)[0]
                elif cnode.is_root():
                    final_node_assignment[cnode.identifier.decode("UTF-8")] = '0'
                else:
                    parent = cnode.parent
                    #in depth-first, this should always be accessible.
                    parent_state = final_node_assignment[parent.identifier.decode("UTF-8")]
                    if parent_state not in current_state:
                        #if the parent state is not part of the multiple options for this node, just take the first one.
                        final_node_assignment[cnode.identifier.decode("UTF-8")] = list(current_state)[0]
                    else:
                        final_node_assignment[cnode.identifier.decode("UTF-8")] = parent_state
        print("{} final assignments".format(len(final_node_assignment)),file=sys.stderr)
        return final_node_assignment

    def ladderize(self) -> None:
        """
        Sort the branches of the tree according to the size of each partition.
        """
        self.t.rotate_for_consistency()

    @_check_newick_only
    def reverse_strand(self, genome_size: int = 29903) -> None:
        """
        Inverts the tree representation of mutations such that all mutations are with respect to the reverse strand of the reference.
        All bases are complemented and indeces are reversed. The tree structure itself and parsimony scores are unaffected.

        Args:
            genome_size (int): The size of the genome. Assumes SARS-CoV-2 if not specified.
        """
        cdef vector[Node*] nodes = self.t.depth_first_expansion(self.t.root)
        cdef vector[Mutation] nmv 
        cdef Mutation newmut
        for i in range(nodes.size()):
            nmv.clear()
            for mutation in nodes[i].mutations:
                newmut = mutation.copy()
                newmut.ref_nuc = complement(mutation.ref_nuc)
                newmut.par_nuc = complement(mutation.par_nuc)
                newmut.mut_nuc = complement(mutation.mut_nuc)
                newmut.position = genome_size - mutation.position - 1
                nmv.push_back(newmut)
            #since nodes[i] is a pointer to the original node object, we can simply edit it inplace.
            nodes[i].mutations = nmv
        
    def list_clades(self) -> set[str]:
        """Return a set of all valid clade annotations in the tree that can be used with get_clade and other functions.

        Returns:
            set[str]: Set of all valid clade annotations.
        """
        clades = set()
        cdef vector[Node*] nodes = self.t.depth_first_expansion(self.t.root)
        cdef vector[string] anns
        for i in range(nodes.size()):
            anns = nodes[i].clade_annotations
            for j in range(anns.size()):
                if anns[j].size() > 0:
                    clades.add(anns[j].decode("UTF-8"))
        return clades

    def create_node(self, identifier: str, parent_id: str, mutations: list[str] = [], annotations: list[str] = [], branch_length: float = 0.0):
        """Create a new node and place it in the tree without generating a wrapper.
        This does not return a MATNode object, so access to the created node will require a subsequent 
        get_node call or using the MATNode constructor method to add the node to the tree.

        Args:
            identifer (str): The identifier of the new node.
            
            parent_id (str): The identifier of the parent node.

            mutations (list[str]): A list of mutations to add to the new node. Mutation strings should be formatted as chro:reflocalt e.g. chr1:A234G. If chromosome is left off, assumes SARS-CoV-2 chromosome.

            annotations (list[str]): A list of annotations to add to the new node. Currently limited to 2 or less.

            branch_length (float): The length of the branch between the new node and its parent. If not specified, the branch length is equal to the number of mutations.
        """
        if len(annotations) > 2:
            raise ValueError("Cannot have more than 2 annotations per node due to internal implementation limitations.")
        if branch_length == 0.0:
            branch_length = float(len(mutations))
        cdef float blen = branch_length
        cdef Node* newnode = self.t.create_node(identifier.encode("UTF-8"),parent_id.encode("UTF-8"),blen)
        cdef bte.Mutation newmut
        for m in mutations:
            newmut = instantiate_mutation(m)
            newnode.mutations.push_back(newmut)
        for a in annotations:
            newnode.clade_annotations.push_back(a)
        
    def move_node(self, to_move: str, new_parent: str) -> None:
        """Move a node from its current parent to a new parent. 

        Args:
            to_move (str): The identifier of the node to move.

            new_parent (str): The identifier of the new parent of the node.
        """
        self.t.move_node(to_move.encode("UTF-8"), new_parent.encode("UTF-8"), True)

    def remove_node(self, to_remove: str) -> None:
        """Remove a node from the tree. This is a destructive operation. 
        WARNING: It can cause segmentation faults if children are left orphaned.

        Args:
            to_remove (str): The identifier of the node to remove.
        """
        self.t.remove_node(to_remove.encode("UTF-8"), True)

    def apply_node_annotations(self, annotations: dict[str,list[str]]) -> None:
        """Apply annotations to the tree. Replaces any annotations on nodes affected.

        Args:
            annotations (dict[str,list[str]]): A dictionary of annotations to apply to the tree, keyed on node_id with a list of annotation strings as the value.
        """
        cdef Node* node
        for nid, annv in annotations.items():
            node = self.t.get_node(nid.encode("UTF-8"))
            node.clear_annotations()
            for an in annv:
                node.clade_annotations.push_back(an.encode("UTF-8"))
        
    def get_annotations(self) -> dict[str,str]:
        """
        Return a dictionary keyed on all annotations with values of the internal node they are defined by. 

        Returns:
            dict[str,str]: A dictionary of annotations with the root node they are associated with.
        """
        claderoots = {}
        cdef vector[Node*] nodes = self.t.depth_first_expansion(self.t.root)
        cdef vector[string] anns
        for i in range(nodes.size()):
            anns = nodes[i].clade_annotations
            for j in range(anns.size()):
                if anns[j].size() > 0:
                    claderoots[anns[j].decode("UTF-8")] = nodes[i].identifier.decode("UTF-8")
        return claderoots

    def dump_node_annotations(self) -> dict[str,list[str]]:
        """Return a dictionary of internal node ids with corresponding annotation root labels. 
        Formatted for compatibility with apply_node_annotations().
        If a node is not included, it does not have any associated annotation roots.

        Returns:
            dict[str,list[str]]: A dictionary of nodes with the annotation roots they are associated with. 
        """
        claderoots = {}
        cdef vector[Node*] nodes = self.t.depth_first_expansion(self.t.root)
        cdef vector[string] anns
        for i in range(nodes.size()):
            anns = nodes[i].clade_annotations
            for j in range(anns.size()):
                if anns[j].size() > 0:
                    nid = nodes[i].identifier.decode("UTF-8")
                    if nid not in claderoots:
                        claderoots[nid] = []
                    claderoots[nid].append(anns[j].decode("UTF-8"))
        return claderoots

    def translate(self, gtf_file: str, fasta_file: str) -> dict[str,list[AAChange]]:
        """
        Translate amino acid changes across the tree and return the results as a dictionary of node IDs and class objects representing amino acid changes as returned from matUtils translate. 
        The translation is representative of the tree at the time of this function being called only.

        Args:
            gtf_file (str): The path to the GTF file containing gene information. 
            fasta_file (str): The path to the FASTA file containing the reference genome.
        """
        if not exists(gtf_file):
            print("ERROR: GTF file {} not found!".format(gtf_file))
            sys.exit(1)
        if not exists(fasta_file):
            print("ERROR: FASTA file {} not found!".format(fasta_file))
            sys.exit(1)
        translation_table = {}
        cdef vector[pair[string,string]] changes = bte.do_translation(&self.t,gtf_file.encode("UTF-8"),fasta_file.encode("UTF-8"))
        for i in range(changes.size()):
            translation_table[changes[i].first.decode("UTF-8")] = _generate_translations(changes[i].second.decode("UTF-8"))
        return translation_table

    def tree_entropy(self, categorical: dict[str,str], from_node: str = "") -> dict[str,float]:
        """
        Calculate the absolute and relative entropy of each split in the tree with respect to a categorical tip trait map. 
        If a node is specified, the entropy map of the subtree rooted at that node is returned.
        If no node is specified, the entropy map of the entire tree is returned.

        Args:
            categorical (dict[str,str]): A dictionary of categorical trait values with the sample IDs as keys.
            from_node (str): The identifier of the node to calculate the entropy from. If not specified, the entropy map of the entire tree is returned.
        """
        ##TODO: this implementation relies on python wrapper-level code. It could be further optimized with the use of C++ typed maps and direct access to Node* pointers.
        node_entropy_map = {}
        nvcd = {}
        sample_count_map = {}
        total_samples = 0
        nodes = self.depth_first_expansion(from_node)
        for n in nodes[::-1]:
            if n.is_leaf():
                catval = categorical.get(n.id,None)
                if catval == None:
                    raise KeyError("Categorical trait value not found for sample ID: " + n.id)
                nvcd[n.id] = {catval:1}
                sample_count_map[n.id] = 1
                total_samples += 1
            else:
                freq_map = {}
                total = 0
                for c in n.children:
                    childd = nvcd[c.id]            
                    for catval, count in childd.items():
                        total += count
                        if catval not in freq_map:
                            freq_map[catval] = count
                        else:
                            freq_map[catval] += count
                nvcd[n.id] = freq_map
                ev = entropy([v/total for v in freq_map.values()])
                if ev > 0:
                    rel_ev = ev - sum([node_entropy_map.get(c.id,(0,0))[0]*sample_count_map[c.id]/total_samples for c in n.children])
                    node_entropy_map[n.id] = (ev, rel_ev)
                sample_count_map[n.id] = total
        return node_entropy_map

    def LCA(self, node_ids: list) -> str:
        '''
        Find the last common ancestor of the input node IDs.

        Args:
            node_ids list[str]: A set of node_ids in string format. Must have a length of at least 2.
        Returns:
            str: The node_id of the last common ancestor.
        '''
        if len(node_ids) < 2:
            raise ValueError("LCA requires a list with at two node IDs.")
        possible_lcas_order = [anc.id for anc in self.rsearch(node_ids[0])]
        possible_lcas = set(possible_lcas_order)
        for nid in node_ids[1:]:
            new_ancestors = set([anc.id for anc in self.rsearch(nid)])
            possible_lcas = possible_lcas.intersection(new_ancestors)
            #if only one choice is left, just return that.
            if len(possible_lcas) == 1:
                return possible_lcas.pop()
        #otherwise, return the element of possible_lcas that's earliest in the order.
        for pl in possible_lcas_order:
            if pl in possible_lcas:
                return pl